import{_ as i,c as s,o as l,ag as n}from"./chunks/framework.CPUF7_g-.js";const c=JSON.parse('{"title":"Java 抽象类和接口","description":"","frontmatter":{},"headers":[],"relativePath":"JAVA/05-abstract-and-interface.md","filePath":"JAVA/05-abstract-and-interface.md"}'),e={name:"JAVA/05-abstract-and-interface.md"};function t(h,a,p,r,k,d){return l(),s("div",null,a[0]||(a[0]=[n(`<h1 id="java-抽象类和接口" tabindex="-1">Java 抽象类和接口 <a class="header-anchor" href="#java-抽象类和接口" aria-label="Permalink to &quot;Java 抽象类和接口&quot;">​</a></h1><h2 id="_1-抽象类" tabindex="-1">1. 抽象类 <a class="header-anchor" href="#_1-抽象类" aria-label="Permalink to &quot;1. 抽象类&quot;">​</a></h2><h3 id="_1-1-什么是抽象类" tabindex="-1">1.1 什么是抽象类 <a class="header-anchor" href="#_1-1-什么是抽象类" aria-label="Permalink to &quot;1.1 什么是抽象类&quot;">​</a></h3><ul><li>使用 <code>abstract</code> 关键字声明的类</li><li>可以包含抽象方法和具体方法</li><li>不能被实例化，只能被继承</li><li>子类必须实现所有抽象方法</li></ul><h3 id="_1-2-抽象类的特点" tabindex="-1">1.2 抽象类的特点 <a class="header-anchor" href="#_1-2-抽象类的特点" aria-label="Permalink to &quot;1.2 抽象类的特点&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    protected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 构造方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 抽象方法：子类必须实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeSound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 具体方法：子类可以直接使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;正在睡觉&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_1-3-使用场景" tabindex="-1">1.3 使用场景 <a class="header-anchor" href="#_1-3-使用场景" aria-label="Permalink to &quot;1.3 使用场景&quot;">​</a></h3><ul><li>当多个类有共同的行为，但具体实现不同</li><li>需要共享代码，但又要强制子类实现某些方法</li><li>需要提供一些默认实现，同时允许子类重写</li></ul><h2 id="_2-接口" tabindex="-1">2. 接口 <a class="header-anchor" href="#_2-接口" aria-label="Permalink to &quot;2. 接口&quot;">​</a></h2><h3 id="_2-1-什么是接口" tabindex="-1">2.1 什么是接口 <a class="header-anchor" href="#_2-1-什么是接口" aria-label="Permalink to &quot;2.1 什么是接口&quot;">​</a></h3><ul><li>使用 <code>interface</code> 关键字声明</li><li>只能包含抽象方法（Java 8 后可以有默认方法）</li><li>所有方法默认是 <code>public abstract</code></li><li>所有字段默认是 <code>public static final</code></li></ul><h3 id="_2-2-接口的特点" tabindex="-1">2.2 接口的特点 <a class="header-anchor" href="#_2-2-接口的特点" aria-label="Permalink to &quot;2.2 接口的特点&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Flyable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抽象方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 默认方法（Java 8+）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> land</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;正在降落&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-3-使用场景" tabindex="-1">2.3 使用场景 <a class="header-anchor" href="#_2-3-使用场景" aria-label="Permalink to &quot;2.3 使用场景&quot;">​</a></h3><ul><li>定义行为规范</li><li>实现多重继承</li><li>解耦接口和实现</li><li>定义回调函数</li></ul><h2 id="_3-抽象类-vs-接口" tabindex="-1">3. 抽象类 vs 接口 <a class="header-anchor" href="#_3-抽象类-vs-接口" aria-label="Permalink to &quot;3. 抽象类 vs 接口&quot;">​</a></h2><h3 id="_3-1-主要区别" tabindex="-1">3.1 主要区别 <a class="header-anchor" href="#_3-1-主要区别" aria-label="Permalink to &quot;3.1 主要区别&quot;">​</a></h3><ol><li><p>继承关系：</p><ul><li>类只能单继承抽象类</li><li>类可以实现多个接口</li></ul></li><li><p>构造方法：</p><ul><li>抽象类可以有构造方法</li><li>接口不能有构造方法</li></ul></li><li><p>字段：</p><ul><li>抽象类可以有实例字段</li><li>接口只能有静态常量</li></ul></li><li><p>方法：</p><ul><li>抽象类可以有具体方法</li><li>接口方法默认是抽象的</li></ul></li></ol><h3 id="_3-2-选择建议" tabindex="-1">3.2 选择建议 <a class="header-anchor" href="#_3-2-选择建议" aria-label="Permalink to &quot;3.2 选择建议&quot;">​</a></h3><ul><li><p>使用抽象类：</p><ul><li>需要共享代码</li><li>有共同的字段</li><li>需要构造方法</li><li>需要控制访问权限</li></ul></li><li><p>使用接口：</p><ul><li>需要定义行为规范</li><li>需要多重继承</li><li>需要解耦</li><li>需要定义回调</li></ul></li></ul><h2 id="_4-实际开发中的最佳实践" tabindex="-1">4. 实际开发中的最佳实践 <a class="header-anchor" href="#_4-实际开发中的最佳实践" aria-label="Permalink to &quot;4. 实际开发中的最佳实践&quot;">​</a></h2><h3 id="_4-1-接口设计原则" tabindex="-1">4.1 接口设计原则 <a class="header-anchor" href="#_4-1-接口设计原则" aria-label="Permalink to &quot;4.1 接口设计原则&quot;">​</a></h3><ul><li>接口要小而专注</li><li>避免接口污染</li><li>优先使用组合而不是继承</li><li>遵循接口隔离原则</li></ul><h3 id="_4-2-抽象类设计原则" tabindex="-1">4.2 抽象类设计原则 <a class="header-anchor" href="#_4-2-抽象类设计原则" aria-label="Permalink to &quot;4.2 抽象类设计原则&quot;">​</a></h3><ul><li>抽象类要包含共同的行为</li><li>抽象方法要少而精</li><li>提供有用的默认实现</li><li>考虑子类的扩展性</li></ul><h2 id="_5-练习题" tabindex="-1">5. 练习题 <a class="header-anchor" href="#_5-练习题" aria-label="Permalink to &quot;5. 练习题&quot;">​</a></h2><ol><li><p>创建一个 <code>Vehicle</code> 抽象类，包含：</p><ul><li>抽象方法 <code>start()</code></li><li>具体方法 <code>stop()</code></li><li>子类 <code>Car</code> 和 <code>Motorcycle</code></li></ul></li><li><p>创建接口：</p><ul><li><code>FuelPowered</code>：加油方法</li><li><code>ElectricPowered</code>：充电方法</li><li>实现类 <code>HybridCar</code> 同时实现这两个接口</li></ul></li></ol><h2 id="_6-扩展阅读" tabindex="-1">6. 扩展阅读 <a class="header-anchor" href="#_6-扩展阅读" aria-label="Permalink to &quot;6. 扩展阅读&quot;">​</a></h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="noreferrer">Oracle Java 教程 - 抽象类</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html" target="_blank" rel="noreferrer">Oracle Java 教程 - 接口</a></li><li><a href="https://www.baeldung.com/java-8-new-features" target="_blank" rel="noreferrer">Java 8 接口新特性</a></li></ul>`,29)]))}const E=i(e,[["render",t]]);export{c as __pageData,E as default};
